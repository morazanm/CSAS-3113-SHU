\documentclass{beamer}
\usepackage{alltt}
\usepackage{tikz}
\usetikzlibrary{matrix}
\usetikzlibrary{trees}
\usepackage{cancel}
\usepackage{subcaption}
\PassOptionsToPackage{obeyspaces}{url}
\usepackage{hyperref}
\usepackage{adjustbox}

\usepackage{lipsum}

\usetheme{Hannover}

\usepackage{background}
\backgroundsetup{
    placement=center,
    angle=0,
    scale=20,
    contents={\textcolor{darkgreen}{$\lambda$}},
    opacity=0.2
}
\setbeamertemplate{background}{\BgMaterial}

\newcommand{\racket}{\texttt{Racket}}
\newcommand{\drr}{\texttt{DrRacket}}
\newcommand{\fsm}{\texttt{FSM}}
\newcommand{\ide}{\texttt{IDE}}
\newcommand{\api}{\texttt{API}}
\newcommand{\arrow}{\(\rightarrow\)}
\newcommand{\dotss}{\(\ldots\)}
\newcommand{\vdotss}{\(\vdots\)}
\newcommand{\elist}{\texttt{\textquotesingle{()}}}
\newcommand{\logand}{\texttt{\(\wedge\)}}
\newcommand{\logor}{\texttt{\(\vee\)}}
\newcommand{\imp}{\texttt{\(\Rightarrow\)}}
\newcommand{\sig}{\texttt{\(\Sigma\)}}
\newcommand{\delt}{\texttt{\(\delta\)}}
\newcommand{\sigsig}{\texttt{\(\Sigma\) = \{a b\}}}
\newcommand{\gam}{\texttt{\(\Gamma\)}}
\newcommand{\ep}{\texttt{\(\epsilon\)}}
\newcommand{\quot}{\texttt{\textquotesingle{}}}
\newcommand{\dquot}{\texttt{"}}
\newcommand{\qquot}{\texttt{\textasciigrave{}}}
\newcommand{\lambexpr}{\texttt{$\lambda$}-expression}
\newcommand{\lamb}{\texttt{$\lambda$}}
\newcommand{\is}{\texttt{::=}}

\definecolor{darkgreen}{RGB}{102,170,102}

\begin{document}

\title{Part V: Continuation-Passing Interpreters}
%\subtitle{Using Beamer}
\author{Marco T. Moraz\'{a}n}
\institute{Seton Hall University}
\date{}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}
\frametitle{Outline}
\tableofcontents
\end{frame}


\section{Continuation-Passing Interpreter}

\begin{frame}[fragile]
\frametitle{Continuation-Passing Interpreters}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> Environments establish the \textit{context} in which each portion of a program is evaluated

\item<2-> We shall now study the control context

\item<2-> The control context dictates how a computation proceeds

\item<3-> Think of a computation as divided in two parts
  \begin{itemize}
    \item the evaluation of a function call for the value of an argument
    \item the rest of the computation that uses the result obtained
  \end{itemize}

\item<4-> The control context is made explicit (just as environments)

\item<5-> A \textit{continuation} is an abstraction for the control context

\item<5-> A continuation knows how to finish a computation after an intermediate value is computed

\item<5-> We say that a continuation is applied to an intermediate value to finish the computation

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Continuation-Passing Interpreters}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> Consider:
\begin{alltt}
(define (add a b)
	(if (= b 0)
        a
        (+ 1 (add a (- b 1)))))
\end{alltt}

\item<2-> Trace \texttt{(add 3 3)}:
\begin{alltt}
= (+ 1 (add 3 2))
= (+ 1 (+ 1 (add 3 1)))
= (+ 1 (+ 1 (+ 1 (add 3 0))))
= (+ 1 (+ 1 (+ 1 3)))	
= (+ 1 (+ 1 4))			
= (+ 1 5)			
= 6
\end{alltt}

\item<3-> Each recursive call comes with the promise that its result will be added to one (this is control: finish the recursive call then come back to add 1)

\item<3-> The control context grows with every function call (i.e., more promises to remember)


\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Continuation-Passing Interpreters}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> Consider:
\begin{alltt}
(define (add a b)
	(define (add-iter b res)
	  (if (= b 0)
          res
          (add-iter (- b 1) (+ res 1))))
  (add-iter b a))
\end{alltt}

\item<2-> Trace \texttt{(add 3 3)}:
\begin{alltt}
= (add-iter 3 3)
= (add-iter 2 4)
= (add-iter 1 5)
= (add-iter 0 6)
= 6		
\end{alltt}

\item<3-> Add iter is always invoked in the same control context

\item<3-> Call at the tail-end means no promises to do anything (no need to return and do anything)

\item<3-> No need to remember what to do with the result

\item<3-> Only a constant amount of memory is needed regardless of the number of (recursive) calls: memory for \texttt{a} and for \texttt{b}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Continuation-Passing Interpreters}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1->
\begin{alltt}
(define (add a b)
  (if (= b 0)
      a
      (+ 1 (add a (- b 1)))))
\end{alltt}

\item<1-> Function is called in an \emph{operand position}

\item<1-> Requires remembering the context to finish evaluating the outer call later (i.e., add the 1)


\item<2-> \textcolor{darkgreen}{\textbf{IT IS THE EVALUATION OF OPERANDS, NOT CALLING PROCEDURES, THAT REQUIRES THE CONTROL CONTEXT TO GROW}}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Continuation-Passing Interpreters}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> Goal: Learn to track and manipulate control contexts

\item<2-> Continuations
\begin{itemize}
\item An abstraction for th control context notion

\item Our interpreter will explicitly pass a continuation (i.e., do this when operand is evaluated)

\item Represents a procedure that takes the result of an operand expression and completes the computation

\item A continuation is a function!

\item We will need the ability, therefore, to apply continuations to values
\end{itemize}

\item<3->
\begin{alltt}
;; apply-cont: continuation value \arrow{} expval
;; Purpose: To apply the given continuation to the
;;          given value and return the final answer
\end{alltt}

\item<3-> A value may be anything that is computed by the program or that is computed to evaluate the program

\item<4-> We shall discover the needed continuation constructors as we analyze the LETREC language interpreter

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Continuation-Passing Interpreters}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1->
\begin{alltt}
;; value-of-program : program \arrow{} expval
(define (value-of-program pgm)
  (cases program pgm
    (a-program (exp1)
               (value-of/k exp1 (init-env)))))
\end{alltt}

\item<1-> The value of \texttt{exp1} must be evaluated. \textcolor{red}{What needs to be done with its value?}

\item<2-> We need a continuation that simply returns the value it is applied to

\item<3->
\begin{alltt}
;; value-of-program : program \arrow{} expval
(define (value-of-program pgm)
  (cases program pgm
    (a-program (exp1)
               (value-of/k exp1 (init-env) (end-cont)))))
\end{alltt}

\item<3-> Semantics:
\begin{alltt}
  (apply-cont (end-cont) val)
= (begin (display "End of computation.\textbackslash{}n‚Äù) val)
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Continuation-Passing Interpreters}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1->
\begin{alltt}
;; value-of : expression environment \arrow{} expval
(define (value-of exp env)
  (cases expression exp

    (const-exp (num) (num-val num))
\end{alltt}

\item<1-> The computation ends by returning a value

\item<1-> In continuation-passing style, the continuation must finish the computation

\item<2->
\begin{alltt}
;; expression environment continuation \arrow{} expval
(define (value-of/k exp env k)
  (cases expression exp

    (const-exp (num) (apply-cont k (num-val num)))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Continuation-Passing Interpreters}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1->
\begin{alltt}
;; value-of : expression environment \arrow{} expval
(define (value-of exp env)
  (cases expression exp

    (true-exp () (bool-val #t))

    (false-exp () (bool-val #f))
\end{alltt}

\item<1-> The computation ends by returning a value

\item<1-> In continuation-passing style, the continuation must finish the computation

\item<2->
\begin{alltt}
;; expression environment continuation \arrow{} expval
(define (value-of/k exp env k)
  (cases expression exp

    (true-exp () (apply-cont k (bool-val #t)))

    (false-exp () (apply-cont k (bool-val #f)))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Continuation-Passing Interpreters}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1->
\begin{alltt}
;; value-of : expression environment \arrow{} expval
(define (value-of exp env)
  (cases expression exp

    (var-exp (var) (apply-env env var))
\end{alltt}

\item<1-> The computation ends by returning a value

\item<1-> In continuation-passing style, the continuation must finish the computation

\item<2->
\begin{alltt}
;; expression environment continuation \arrow{} expval
(define (value-of/k exp env k)
  (cases expression exp

    (var-exp (var) (apply-cont k (apply-env env var)))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Continuation-Passing Interpreters}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1->
\begin{alltt}
;; value-of : expression environment \arrow{} expval
(define (value-of exp env)
  (cases expression exp

    (proc-exp (params body)
              (proc-val (procedure params body (vector env))))
\end{alltt}

\item<1-> The computation ends by returning a value

\item<1-> In continuation-passing style, the continuation must finish the computation

\item<2->
\begin{alltt}
;; expression environment continuation \arrow{} expval
(define (value-of/k exp env k)
 (cases expression exp

  (proc-exp (params body)
   (apply-cont k (proc-val (procedure params body (vector env)))))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Continuation-Passing Interpreters}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1->
\begin{alltt}
;; value-of : expression environment \arrow{} expval
(define (value-of exp env)
  (cases expression exp

    (zero?-exp (exp1)
               (let ((val1 (expval2num (value-of exp1 env))))
                 (if (zero? val1)
                     (bool-val #t)
                     (bool-val #f))))
\end{alltt}

\item<1-> There is one non-tail call: evaluate \texttt{exp1}

\item<1-> In continuation-passing style, the continuation must finish the computation

\item<2->
\begin{alltt}
;; expression environment continuation \arrow{} expval
(define (value-of/k exp env k)
  (cases expression exp

    (zero?-exp (exp1)
               (value-of/k exp1 env (zero?-cont k)))
\end{alltt}

\item<2-> Save the given continuation, \texttt{k}, to use after value of \texttt{exp1} is known to finish the computation

\item<3-> Semantics
\begin{alltt}
  (apply-cont (zero?-cont cont) val)
= (if (zero? (expval2num val))
      (apply-cont cont (bool-val #t))
      (apply-cont cont (bool-val #f)))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Continuation-Passing Interpreters}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1->
\begin{alltt}
;; value-of : expression environment \arrow{} expval
(define (value-of exp env)
  (cases expression exp

    (if-exp (exp1 exp2 exp3)
            (let ((val1 (value-of exp1 env)))
              (if (expval2bool val1)
                  (value-of exp2 env)
                  (value-of exp3 env))))
\end{alltt}

\item<1-> There is one non-tail call: evaluate \texttt{exp1}

\item<1-> To finish the computation \texttt{exp2}, \texttt{exp3}, and \texttt{env} must be remembered

\item<1-> Since a concrete value is not returned, the continuation must be remembered to be used after evaluating \texttt{exp2} or \texttt{exp3}

\item<2->
\begin{alltt}
;; expression environment continuation \arrow{} expval
(define (value-of/k exp env k)
  (cases expression exp

    (if-exp (exp1 exp2 exp3)
            (value-of/k exp1 env (if-cont exp2 exp3 env k)))
\end{alltt}

\item<3-> Semantics
\begin{alltt}
  (apply-cont (if-cont (exp2 exp3 env saved-cont) val)
= (if (expval2bool val)
      (value-of/k exp2 env saved-cont)
      (value-of/k exp3 env saved-cont)))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Continuation-Passing Interpreters}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1->
\begin{alltt}
;; value-of : expression environment \arrow{} expval
(define (value-of exp env)
 (cases expression exp

  (letrec-exp (names params bodies letrec-body)
   (value-of letrec-body (mk-letrec-env names params bodies env)))
\end{alltt}

\item<1-> There is one non-tail call: Create a letrec-env

\item<1-> To finish the computation \texttt{letrec-body} must be remembered to evaluate it after the environment is computed

\item<1-> Since a concrete value is not returned, the continuation must be remembered to be used after evaluating \texttt{letrec-body}
\item<2->
\begin{alltt}
;; expression environment continuation \arrow{} expval
(define (value-of/k exp env k)
 (cases expression exp

  (letrec-exp (names params bodies letrec-body)
   (mk-letrec-env/k names params bodies env (letrec-cont letrec-body k)))
\end{alltt}

\item<3-> Semantics
\begin{alltt}
  (apply-cont (letrec-cont letrec-body saved-cont) val)
= (value-of/k letrec-body val saved-cont))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Continuation-Passing Interpreters}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1->
\begin{alltt}
;; value-of : expression environment \arrow{} expval
(define (value-of exp env)
 (cases expression exp
  (let-exp (vars exps body)
   (let [(vals (map (lambda (e) (value-of e env)) exps))]
    (value-of body (foldr (lambda (var val acc)
                            (extend-env var val acc))
                           env vars vals))))
\end{alltt}

\item<1-> There are two non-tail calls: \texttt{map} and \texttt{foldr}

\item<1-> To finish the computation \texttt{body}, \texttt{vars}, and \texttt{env} must be remembered

\item<1-> The continuation remembered to use after evaluating \texttt{body}

\item<2->
\begin{alltt}
;; expression environment continuation \arrow{} expval
(define (value-of/k exp env k)
  (cases expression exp
    (let-exp (vars exps body)
             (eval-rands/k exps env (let1-cont vars body env k)))
\end{alltt}

\item<2-> Save the given continuation, \texttt{k}, to use after value of \texttt{body} is known to finish the computation

\item<3-> Semantics
\begin{alltt}
  (apply-cont (let1-cont (vars body env saved-cont)) val)
= (create-let-lenv vars val env (let2-cont body saved-cont))

  (apply-cont (let2-cont (body saved-cont)) val)
= (value-of/k body val saved-cont)
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Continuation-Passing Interpreters}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1->
\begin{alltt}
;; value-of : expression environment \arrow{} expval
(define (value-of exp env)
  (cases expression exp

    (diff-exp (exp1 exp2)
              (let ((num1 (expval2num (value-of exp1 env)))
                    (num2 (expval2num (value-of exp2 env))))
                (num-val (- num1 num2))))
\end{alltt}

\item<1-> There are two non-tail function calls evaluate \texttt{exp1} and evaluate \texttt{exp2}

\item<1-> To finish the computation after evaluating \texttt{exp1}, the value of \texttt{exp2} and \texttt{env} must be remembered

\item<1-> Since a concrete value is not returned, the continuation must be remembered to be used after evaluating \texttt{exp1}

\item<2->
\begin{alltt}
    (diff-exp (exp1 exp2)
              (value-of/k exp1 env (diff-cont1 exp2 env k)))
\end{alltt}

\item<2-> A continuation is needed to finish the computation when \texttt{exp2} is evaluated

\item<2-> Must remember the value of \texttt{exp1} and the continuation to use after \texttt{exp2} is evaluated

\item<3-> Semantics
\begin{alltt}
  (diff-cont1 (exp2 env saved-cont)
= (value-of/k exp2 env (diff-cont2 val saved-cont)))

  (diff-cont2 (val1 saved-cont)
= (apply-cont saved-cont (num-val (- (expval2num val1)
                                     (expval2num val)))))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Continuation-Passing Interpreters}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1->
\begin{alltt}
;; value-of : expression environment \arrow{} expval
(define (value-of exp env)
  (cases expression exp
    (call-exp (rator rands)
              (let [(proc (expval2proc (value-of rator env)))
                    (args (map (lambda (rand) (value-of rand env)) rands))]
                (apply-procedure proc args)))
\end{alltt}

\item<1-> There are two non-tail function calls:
\begin{itemize}
\item Evaluate \texttt{rator}

\item Evaluate \texttt{rands}
\end{itemize}

\item<1-> To finish the computation after evaluating \texttt{rator}, the value of \texttt{rands} and \texttt{env} must be remembered

\item<1-> Since a concrete value is not returned, the continuation must be remembered to be used after evaluating \texttt{rator}

\item<2->
\begin{alltt}
  (rator-cont (rands env saved-cont)
              (eval-rands/k rands env (rands-cont val saved-cont)))
\end{alltt}

\item<2-> The continuation is needed to finish computation after \texttt{rands} are evaluated

\item<2-> Must remember \texttt{rator} value to use after \texttt{rands} is evaluated

\item<4-> Semantics
\begin{alltt}
  (rator-cont (rands env saved-cont)
= (eval-rands/k rands env (rands-cont val saved-cont)))

  (rands-cont (rator saved-cont)
= (apply-procedure/k (expval2proc rator) val saved-cont))
\end{alltt}

\item<4-> \texttt{apply-procedure} needs the saved continuation, because it calls \texttt{value-of}.

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Continuation-Passing Interpreters}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> 
\begin{alltt}
;; proc (listof expval) continuation \arrow{} expval
;; Purpose: Apply the given procedure to the given values
(define (apply-procedure/k f vals \textcolor{red}{k})
  (cases proc f
    (procedure (params body envv)
               (let [(saved-env (vector-ref envv 0))]
                 (value-of/k body
                             \textcolor{blue}{(foldr (lambda (binding acc)
                                      (extend-env (car binding)
                                                  (cadr binding)
                                                  acc))
                                    saved-env
                                    (map (lambda (p v) (list p v))
                                         params
                                         vals))}
                             \textcolor{red}{k})))))
\end{alltt}

\item<1-> \textcolor{red}{Continuation input for call to value-of}

\item<1-> \textcolor{blue}{Create new env to evaluate the body assuming \texttt{foldr} and \texttt{map} do not grow the control context}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Continuation-Passing Interpreters}
%\framesubtitle{HOMEWORK}
\begin{tiny}
\begin{itemize}
\item<1-> 
\begin{alltt}
;; (listof symbol) (listof (listof symbol)) (listof expression)
;; environment     continuation 
;; \arrow{} environment
;; Purpose: Add the proc-vals for the given procedures in the given environment
(define (mk-letrec-env/k names params bodies env k)
  (let* [(temp-proc-vals \textcolor{red}{(map (lambda (p b)
                                (proc-val (procedure p b (vector (empty-env)))))
                              params
                              bodies))}
         (new-env \textcolor{blue}{(foldl (lambda (name proc env) (extend-env name proc env))
                         env
                         names
                         temp-proc-vals)})]
    (begin
      \textcolor{darkgreen}{(for-each (lambda (p)
                  (cases proc p
                    (procedure (p b ve) (vector-set! ve 0 new-env))))
                (map (lambda (p) (expval2proc p)) temp-proc-vals))}
      \textcolor{orange}{(apply-cont k new-env)})))
\end{alltt}

\item<1-> \textcolor{red}{Temporarily create incorrect \texttt{proc-val}s for the locally defined recursive functions assuming \texttt{map} does not grow the control context.}
    
\item<2-> \textcolor{blue}{Createa new env by adding incorrect \texttt{proc}s to the given environment}

\item<3-> \textcolor{darkgreen}{Correct the environment in each incorrect \texttt{proc}}
    
\item<4-> \textcolor{orange}{Finish the computation by applying the continuation to the correct new env}

\end{itemize}
\end{tiny}
\end{frame}

\begin{frame}[fragile]
\frametitle{Continuation-Passing Interpreters}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> 
\begin{alltt}
;; (listof expression) environment continuation \arrow{} expval
;; Purpose: Evaluate the given list of exprs and apply the 
;;          given cont
(define (eval-rands/k rands env k)
  (if (null? rands)
      \textcolor{red}{(apply-cont k \elist{})}
      \textcolor{blue}{(value-of/k (car rands) 
                  env 
                  (eval-rands-cont1 (cdr rands) env k))}))
\end{alltt}

\item<1-> Two steps: evaluate the first argument and evaluate the rest of the arguments

\item<2-> \textcolor{blue}{Evaluate the first argument using a continuation that evaluates the rest of the arguments}
    
\item<3-> \textcolor{red}{If there are no more arguments to evaluate apply the given continuation to the empty list of evaluated arguments}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Continuation-Passing Interpreters}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1->
\begin{alltt}
;; (listof symbol) (listof expval) environment continuation
;; \arrow{} expval
;; Purpose: Apply the given cont to the evn created using the 
;;          given variables, expvals, and environment
;; ACC INVARIANT
;;  env contains the processed bindings
(define (create-let-lenv vars vals env k)
  (if (empty? vars)
      \textcolor{violet}{(apply-cont k env)}
      (create-let-lenv (cdr vars)
                       (cdr vals)
                       \textcolor{orange}{(extend-env (car vars) (car vals) env)}
                       k)))
\end{alltt}

\item<1-> \textcolor{orange}{Accumulate new bindings in the given environment}
    
\item<2-> \textcolor{violet}{If no more bindings to add, apply continuation to the given environment that stores all the bindings}

\item<3-> No new continuations are needed: all function calls in tail-position

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Continuation-Passing Interpreters}
%\framesubtitle{HOMEWORK}
\begin{tiny}
\begin{itemize}
\item<1->
\begin{alltt}
(define-datatype continuation cont?
  (end-cont)
\end{alltt}

\item<2->
\begin{alltt}
  (zero?-cont (k cont?))
\end{alltt}

\item<3->
\begin{alltt}
  (letrec-cont (letrec-body expression?)
               (saved-cont cont?))
\end{alltt}

\item<4->
\begin{alltt}
  (let1-cont (vrs (list-of symbol?))
             (b expression?)
             (e environment?)
             (k cont?))
  (let2-cont (b expression?)
             (k cont?))
\end{alltt}

\item<5->
\begin{alltt}
  (if-cont (e2 expression?)
           (e3 expression?)
           (e environment?)
           (k cont?))
\end{alltt}

\item<6->
\begin{alltt}
  (diff-cont1 (e2 expression?)
              (e environment?)
              (k cont?))
  (diff-cont2 (v1 expval?)
              (k cont?))
\end{alltt}

\item<7->
\begin{alltt}
  (rator-cont (rnds (list-of expression?))
              (e environment?)
              (k cont?))
  (rands-cont (operator expval?)
              (k cont?))
\end{alltt}

\item<8->
\begin{alltt}
  (eval-rands-cont1 (rands (list-of expression?))
                    (e environment?)
                    (k cont?))
  (eval-rands-cont2 (farg expval?)
                    (k cont?)))
\end{alltt}

\end{itemize}
\end{tiny}
\end{frame}

\begin{frame}[fragile]
\frametitle{Continuation-Passing Interpreters}
\framesubtitle{Auxiliary Functions}
\begin{scriptsize}
\begin{itemize}
\item<1->
\begin{alltt}
;; continuation expval \arrow{} expval
;; Purpose: Apply the given cont to the given value and return
;;          the final answer
(define (apply-cont k val)
 (cases continuation k
   (end-cont () val)
\end{alltt}

\item<2->
\begin{alltt}
   (zero?-cont (cont)
     (if (zero? (expval2num val))
                (apply-cont cont (bool-val #t))
                (apply-cont cont (bool-val #f))))
\end{alltt}

\item<3->
\begin{alltt}
   (let1-cont (vars body env saved-cont)
    (create-let-lenv vars val env (let2-cont body saved-cont)))
\end{alltt}

\item<4->
\begin{alltt}
   (let2-cont (body saved-cont)
     (value-of/k body val saved-cont))
\end{alltt}

\item<5->
\begin{alltt}
   (if-cont (exp2 exp3 env saved-cont)
     (if (expval2bool val)
         (value-of/k exp2 env saved-cont)
         (value-of/k exp3 env saved-cont)))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Continuation-Passing Interpreters}
\framesubtitle{Auxiliary Functions}
\begin{scriptsize}
\begin{itemize}
\item<1->
\begin{alltt}
;; continuation expval \arrow{} expval
;; Purpose: Apply the given cont to the given value and return the final answer
(define (apply-cont k val)
  (cases continuation k
    (letrec-cont (letrec-body saved-cont)
     (value-of/k letrec-body val saved-cont))
\end{alltt}

\item<2->
\begin{alltt}
    (diff-cont1 (exp2 env saved-cont)
     (value-of/k exp2 env (diff-cont2 val saved-cont)))
\end{alltt}

\item<3->
\begin{alltt}
    (diff-cont2 (val1 saved-cont)
     (apply-cont saved-cont (num-val (- (expval2num val1)
                                        (expval2num val)))))
\end{alltt}

\item<4->
\begin{alltt}
    (rator-cont (rands env saved-cont)
     (eval-rands/k rands env (rands-cont val saved-cont)))
\end{alltt}

\item<5->
\begin{alltt}
    (rands-cont (rator saved-cont)
     (apply-procedure/k (expval2proc rator) val saved-cont))
\end{alltt}

\item<6->
\begin{alltt}
    (eval-rands-cont1 (rands env saved-cont)
     (eval-rands/k rands env (eval-rands-cont2 val saved-cont)))
\end{alltt}

\item<7->
\begin{alltt}
    (eval-rands-cont2 (first-rand k)
     (apply-cont k (cons first-rand val)))))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> add sum-exp and mult-exp to the interpreter

\item<1-> 5.4, \textbf{5.9**}


\end{itemize}
\end{scriptsize}
\end{frame}

\section{A Trampolined Interpreter}

\begin{frame}[fragile]
\framesubtitle{A Trampolined Interpreter}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> We know will explore how to transform a continuation-passing interpreter to a \emph{regular} PL
    
\item<1-> By regular we mean no HOF

\item<1-> Can use data structure representation of continutations

\item<2-> More problematic:
\begin{itemize}
\item Most PLs \underline{always} grow the control context with every procedure call
    
\item Control context is usually a stack (that always grows with every procedure call)
\end{itemize}

\item<3-> Why do most PLs always grow the control context?

\item<4-> 
\begin{itemize}
\item Almost all procedure calls occur at the RHS of an assignment statement: x = f(\dotss)
    
\item The assignment is a delayed operation and requires growing the control context to track its pending excution
    
\item Environment info is also placed on the stack \& removed

\end{itemize}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{A Trampolined Interpreter}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> One solution for such languages is trampolining

\item<1-> Break an unbounded chain of proc calls by having one of the procedures in the interpreter return a zero-argument proc

\item<1-> When called, this proc continues the computation

\item<1-> The computation bounces from one procedure call to the next

\item<1-> This is controlled by a trampoline procedure

\item<2-> What procedure calls?

\item<3-> Those that are steps in the evaluator: \texttt{value-of/k}, \texttt{apply-cont}, \texttt{apply-procedure/k}, \texttt{eval-rands/k}, and \texttt{mk-letrec-env/k}

\item<3-> Instead of calling one of them (and grow the control context), make calls to these functions the body of a zero-argument function that is given to the trampoline function

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{A Trampolined Interpreter}
%\framesubtitle{HOMEWORK}
\begin{tiny}
\begin{itemize}
\item<1-> Let illustrate how this works
\begin{alltt}
(trampoline (value-of-program (value-of/k -(3, 1) (empty-env) (end-cont))))
\end{alltt}

\item<2->
\begin{alltt}
= (trampoline (lambda () (value-of/k 3 (diff1-cont 1 (empty-env) (end-cont)))))
\end{alltt}

\item<3->
\begin{alltt}
= (trampoline (value-of/k 3 (diff1-cont 1 (empty-env) (end-cont))))
\end{alltt}

\item<4->
\begin{alltt}
= (trampoline (lambda () (apply-cont (diff1-cont 1 (empty-env) (end-cont)) 3)))
\end{alltt}

\item<5->
\begin{alltt}
= (trampoline (apply-cont (diff1-cont 1 (empty-env) (end-cont)) 3))
\end{alltt}

\item<6->
\begin{alltt}
= (trampoline (lambda () (value-of/k 1 (empty-env) (diff-cont2 3 (end-cont)))))
\end{alltt}

\item<7->
\begin{alltt}
= (trampoline (value-of/k 1 (empty-env) (diff-cont2 3 (end-cont))))
\end{alltt}

\item<8->
\begin{alltt}
= (trampoline (lambda () (apply-cont (diff-cont2 3 (end-cont)) 1)))
\end{alltt}

\item<9->
\begin{alltt}
= (trampoline (apply-cont (diff-cont2 3 (end-cont)) 1))
\end{alltt}

\item<10->
\begin{alltt}
= (trampoline (lambda () (apply-cont (end-cont) 2)))
\end{alltt}

\item<11->
\begin{alltt}
= (trampoline (apply-cont (end-cont) 2))
\end{alltt}

\item<12->
\begin{alltt}
= (trampoline (lambda () 2))
\end{alltt}

\item<13->
\begin{alltt}
= (trampoline 2)
\end{alltt}

\item<14->
\begin{alltt}
= 2
\end{alltt}

\end{itemize}
\end{tiny}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{A Trampolined Interpreter}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> Trampoline input value:
\begin{alltt}
A bounce is either:
  1. expval 
  2. A zero-input function
\end{alltt}

\item<2-> Specification:
\begin{itemize}
\item If input is an expval then return it (computation is done)
\item If input is a zero-input function then evaluate and call the trampoline
\end{itemize}

\item<3-> Trampoline implementation:
\begin{alltt}
;; trampoline : bounce \arrow{} expval
(define (trampoline a-bounce)
    (if (expval? a-bounce)
        a-bounce
        (trampoline (a-bounce))))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{A Trampolined Interpreter}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> Wrap every call to \texttt{value-of/k}, \texttt{apply-cont}, \texttt{apply-procedure/k}, \texttt{eval-rands/k}, and \texttt{mk-letrec-env/k} inside a lambda-expression and call trampoline

\item<2-> 
\begin{alltt}
;; value-of-program : Program -> ExpVal
(define (value-of-program pgm)
  (cases program pgm
    (a-program (exp1)
     \textcolor{blue}{(trampoline 
      (lambda () 
       (value-of/k exp1 (empty-env) (end-cont))))})))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{A Trampolined Interpreter}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> Wrap every call to \texttt{value-of/k}, \texttt{apply-cont}, \texttt{apply-procedure/k}, \texttt{eval-rands/k}, and \texttt{mk-letrec-env/k} inside a lambda-expression and call trampoline

\item<1->
\begin{alltt}
;; proc (listof expval) continuation -> bounce
;; Purpose: Apply the given procedure to the given values
(define (apply-procedure/k f vals k)
 (cases proc f
  (procedure (params body envv)
   (let [(saved-env (vector-ref envv 0))]
    \textcolor{blue}{(trampoline
     (lambda ()
      (value-of/k body
                  (foldr (lambda (binding acc)
                          (extend-env (car binding)
                                      (cadr binding)
                                      acc))
                         saved-env
                         (map (lambda (p v) (list p v))
                              params
                              vals))
                  k)))}))))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{A Trampolined Interpreter}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> Wrap every call to \texttt{value-of/k}, \texttt{apply-cont}, \texttt{apply-procedure/k}, \texttt{eval-rands/k}, and \texttt{mk-letrec-env/k} inside a lambda-expression and call trampoline

\item<1->
\begin{alltt}
;; (listof expression) environment continuation --> expval
;; Purpose: Evaluate the given list of exprs and apply the given cont
(define (eval-rands/k rands env k)
  (if (null? rands)
      \textcolor{blue}{(trampoline (lambda () (apply-cont k \elist{})))}
      \textcolor{blue}{(trampoline 
       (lambda () 
        (value-of/k 
         (car rands) env (eval-rands-cont1 (cdr rands) env k))))}))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{A Trampolined Interpreter}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> Wrap every call to \texttt{value-of/k}, \texttt{apply-cont}, \texttt{apply-procedure/k}, \texttt{eval-rands/k}, and \texttt{mk-letrec-env/k} inside a lambda-expression and call trampoline

\item<1->
\begin{alltt}
;; (listof symbol) (listof expval) environment continuation --> expval
;; Purpose: Apply the given cont to the evn created usingthe given
;;          variables, expvals, and environment
(define (create-let-lenv vars vals env k)
  (if (empty? vars)
      \textcolor{blue}{(trampoline (lambda () (apply-cont k env)))}
      \textcolor{blue}{(trampoline 
       (lambda () 
        (create-let-lenv (cdr vars)
                         (cdr vals)
                         (extend-env (car vars) 
                                     (car vals) env)
                         k)))}))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{A Trampolined Interpreter}
%\framesubtitle{HOMEWORK}
\begin{tiny}
\begin{itemize}
\item<1-> Wrap every call to \texttt{value-of/k}, \texttt{apply-cont}, \texttt{apply-procedure/k}, \texttt{eval-rands/k}, and \texttt{mk-letrec-env/k} inside a lambda-expression and call trampoline

\item<1->
\begin{alltt}
;; (listof symbol) (listof (listof symbol)) (listof expression) environment continuation --> environment
;; Purpose: Add the proc-vals for the given procedures in the given environment
(define (mk-letrec-env/k names params bodies env k)
  (let* [(temp-proc-vals (map (lambda (p b)
                                (proc-val (procedure p b (vector (empty-env)))))
                              params
                              bodies))
         (new-env (foldl (lambda (name proc env)
                           (extend-env name
                                       proc
                                       env))
                         env
                         names
                         temp-proc-vals))]
    (begin
      (for-each (lambda (p)
                  (cases proc p
                    (procedure (p b ve)
                               (vector-set! ve 0 new-env))))
                (map (lambda (p) (expval2proc p))
                     temp-proc-vals))
      \textcolor{blue}{(trampoline (lambda () (apply-cont k new-env)))})))
\end{alltt}

\end{itemize}
\end{tiny}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{A Trampolined Interpreter}
%\framesubtitle{HOMEWORK}
\begin{tiny}
\begin{itemize}
\item<1-> Wrap every call to \texttt{value-of/k}, \texttt{apply-cont}, \texttt{apply-procedure/k}, \texttt{eval-rands/k}, and \texttt{mk-letrec-env/k} inside a lambda-expression and call trampoline

\item<1->
\begin{alltt}
;; expression environment continuation -> bounce
(define (value-of/k exp env k)
  (cases expression exp
    (const-exp (num) \textcolor{blue}{(trampoline (lambda () (apply-cont k (num-val num))))})
    
    (true-exp () \textcolor{blue}{(trampoline (lambda () (apply-cont k (bool-val #t))))})
    
    (false-exp () \textcolor{blue}{(trampoline (lambda () (apply-cont k (bool-val #f))))})
    
    (var-exp (var) \textcolor{blue}{(trampoline (lambda () (apply-cont k (apply-env env var))))})
    
    (proc-exp (params body)
              \textcolor{blue}{(trampoline
               (lambda ()
                 (apply-cont k (proc-val (procedure params body (vector env))))))})

    (zero?-exp (exp1)
               \textcolor{blue}{(trampoline (lambda () (value-of/k exp1 env (zero?-cont k))))})

    (diff-exp (exp1 exp2)
              \textcolor{blue}{(trampoline
               (lambda () (value-of/k exp1 env (diff-cont1 exp2 env k))))})

    (if-exp (exp1 exp2 exp3)
            \textcolor{blue}{(trampoline
             (lambda () (value-of/k exp1 env (if-cont exp2 exp3 env k))))})
    (let-exp (vars exps body)
             \textcolor{blue}{(trampoline
              (lambda () (eval-rands/k exps env (let1-cont vars body env k))))})
    (call-exp (rator rands)
              \textcolor{blue}{(trampoline
               (lambda () (value-of/k rator env (rator-cont rands env k))))})
    (letrec-exp (names params bodies letrec-body)
                \textcolor{blue}{(trampoline
                 (lambda ()
                   (mk-letrec-env/k names params bodies env (letrec-cont letrec-body k))))})))

\end{alltt}

\end{itemize}
\end{tiny}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{A Trampolined Interpreter}
%\framesubtitle{HOMEWORK}
\begin{tiny}
\begin{itemize}

\item<1->
\begin{alltt}
;; continuation expval --> bounce
;; Purpose: Apply the given cont to the given value and return the final answer
(define (apply-cont k val)
  (cases continuation k
    (end-cont () \textcolor{blue}{(trampoline (lambda () val))})
    (zero?-cont (cont)
     (if (zero? (expval2num val))
         \textcolor{blue}{(trampoline (lambda () (apply-cont cont (bool-val #t))))}
         \textcolor{blue}{(trampoline (lambda () (apply-cont cont (bool-val #f))))}))
    (let1-cont (vars body env saved-cont)
     \textcolor{blue}{(trampoline
      (lambda () (create-let-lenv vars val env (let2-cont body saved-cont))))})
    (let2-cont (body saved-cont)
     \textcolor{blue}{(trampoline (lambda () (value-of/k body val saved-cont)))})
    (if-cont (exp2 exp3 env saved-cont)
     (if (expval2bool val)
         \textcolor{blue}{(trampoline (lambda () (value-of/k exp2 env saved-cont)))}
         \textcolor{blue}{(trampoline (lambda () (value-of/k exp3 env saved-cont)))}))
    (letrec-cont (letrec-body saved-cont)
     \textcolor{blue}{(trampoline (lambda () (value-of/k letrec-body val saved-cont)))})
    (diff-cont1 (exp2 env saved-cont)
     \textcolor{blue}{(trampoline (lambda () (value-of/k exp2 env (diff-cont2 val saved-cont))))})
    (diff-cont2 (val1 saved-cont)
     \textcolor{blue}{(trampoline
      (lambda () (apply-cont saved-cont (num-val (- (expval2num val1) (expval2num val))))))})
    (rator-cont (rands env saved-cont)
     \textcolor{blue}{(trampoline 
      (lambda () (eval-rands/k rands env (rands-cont val saved-cont))))})
    (rands-cont (rator saved-cont)
     \textcolor{blue}{(trampoline
      (lambda () (apply-procedure/k (expval2proc rator) val saved-cont)))})
    (eval-rands-cont1 (rands env saved-cont)
     \textcolor{blue}{(trampoline 
      (lambda () (eval-rands/k rands env (eval-rands-cont2 val saved-cont))))})
    (eval-rands-cont2 (first-rand k)
     \textcolor{blue}{(trampoline (lambda () (apply-cont k (cons first-rand val))))})))
\end{alltt}

\end{itemize}
\end{tiny}
\end{frame}


\section{An Imperative Interpreter}

\begin{frame}[fragile]
\framesubtitle{An Imperative Interpreter}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> How do we implement a continuation-passing interpreter in procedural languages with assignment?

\item<1-> Remember that assignment to \emph{shared} variables may be used in place of a binding

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{An Imperative Interpreter}
%\framesubtitle{HOMEWORK}
\begin{tiny}
\begin{itemize}
\item<1-> Consider
\begin{alltt}
letrec
  even(x) = if zero?(x) then 1 else (odd sub1(x))
  odd(x)   = if zero?(x) then 0 else (even sub1(x))
in (odd 10)
\end{alltt}

\item<2-> Trace
\begin{alltt}
(odd  10)
=  (even 9)
=  (odd   8)
=  (even 7)
=  (odd   6)
=  (even 5)
  \vdotss{}
=  (even 1)
=  (odd   0)
= 0
\end{alltt}

\item<3-> Make \texttt{x} a shared variable
\begin{alltt}
let x = 10
in letrec
       even() = if zero?(x) then 1 else let d = set x = sub1(x) in (odd)
       odd()   = if zero?(x) then 0 else let d = set x = sub1(x) in (even)
in (odd)
\end{alltt}

\item<4-> The trace is the same!
\begin{alltt}
(odd )
=  (even)
=  (odd)
=  (even)
=  (odd)
=  (even)
  \vdotss{}
=  (even)
=  (odd)
= 0
\end{alltt}

\end{itemize}
\end{tiny}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{An Imperative Interpreter}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> This means we can rewrite as in assembly using \texttt{GOTO}s and labels
\begin{alltt}
x = 10;
goto odd;
even: 
  if (x == 0) then return(1) else {x = x-1; goto odd;}
odd: 
  if (x == 0) then return(0) else {x = x-1; goto even;}
\end{alltt}

\item<2-> PC trace is the same!
\begin{alltt}
(odd)
=  (even)
=  (odd)
=  (even)
=  (odd)
=  (even)
   \vdotss{}
=  (even)
=  (odd)
= 0
\end{alltt}

\item<3-> Why are all these traces the same?

\item<4-> Control context does not grow when all function calls are in tail position

\item<4-> This means a function call is the same as a jump

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{An Imperative Interpreter}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> Important lessons

\item<1-> If a set of procs call each other using tail-calls we can rewrite them to use assignment instead of an env
    
\item<1->REMEMBER: Values in one function call do not need to be remembered after another call is made because all calls are tail calls (no delayed operations)

\item<2-> The assignment-based program can be rewritten using \texttt{GOTO}s and labels
    
\item<3-> We need to identify which procedures need to communicate values

\item<3-> Use registers to hold those values

\item<3-> Write an imperative interpreter

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{An Imperative Interpreter}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> Let's start with out continuation-passing interpreter (not the trampolined interpreter)
    
\item<1-> Functions that need to share values via registers:
\begin{itemize}
\item (value-of/k \textcolor{orange}{exp} \textcolor{darkgreen}{env} \textcolor{blue}{cont})
\item (apply-cont \textcolor{blue}{cont} \textcolor{red}{val})
\item (apply-procedure/k \textcolor{brown}{proc1} \textcolor{red}{val} \textcolor{blue}{cont})
\item (eval-rands/k \textcolor{teal}{rands} \textcolor{darkgreen}{env} \textcolor{blue}{cont})
\item (create-let-lenv \textcolor{olive}{vars} \textcolor{purple}{vals} \textcolor{darkgreen}{env} \textcolor{blue}{cont})
\item (mk-letrec-env/k \textcolor{gray}{names} \textcolor{green}{params} \textcolor{pink}{bodies} \textcolor{darkgreen}{env} \textcolor{blue}{cont})
\end{itemize}

\item<1-> How many registers (i.e., state variables) do we need?

\item<2-> 11 registers given all calls are tail calls
\begin{itemize}
\item exp
\item env
\item cont
\item val
\item proc1
\item rands
\item vars
\item vals
\item letrec-names
\item letrec-params
\item letrec-bodies
\end{itemize}


\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{An Imperative Interpreter}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> How do 11 registers help us?

\item<2-> Replace each function with a zero-argument proc

\item<2-> A function call stores parameter values in the registers and then calls
    
\item<3-> Three possible scenarios:
\begin{itemize}
\item Register is unchanged then do nothing

\item Make sure field names in cases expression do not shadow a register. If so, rename local vars

\item If a register is used twice in a single call then carefully sequence assignments to have the right values in registers and/or use temporary vars
\end{itemize}

\item<3->This process is called registerization

\item<3-> From here it is easily translatable into an imperative language (e.g. C)

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{An Imperative Interpreter}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> 
\begin{alltt}
;;; The registers

(define exp   (void))
(define env   (void))
(define cont  (void))
(define val   (void))
(define proc1 (void))
(define rands (void))
(define vars  (void))
(define vals  (void))
(define letrec-names  (void))
(define letrec-params (void))
(define letrec-bodies (void))
\end{alltt}


\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{An Imperative Interpreter}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> 
\begin{alltt}
;; value-of-program : Program -> ExpVal
(define (value-of-program pgm)
  (cases program pgm
    (a-program (exp1)
               (value-of/k exp1 (empty-env) (end-cont)))))
\end{alltt}

\item<1-> Becomes
\begin{alltt}
;; value-of-program : Program -> ExpVal
(define (value-of-program pgm)
  (cases program pgm
    (a-program (exp1)
               (begin
                 (set! exp exp1)
                 (set! env (empty-env))
                 (set! cont (end-cont))
                 (value-of/k)))))
\end{alltt}


\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{An Imperative Interpreter}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> 
\begin{alltt}
;; expression environment continuation -> expval
(define (value-of/k)
  (cases expression exp

    (const-exp (num)
               (apply-cont k (num-val num)))
\end{alltt}

\item<1-> Becomes
\begin{alltt}
;; expression environment continuation -> expval
(define (value-of/k)
  (cases expression exp

    (const-exp (num)
               (begin
                 (set! val (num-val num))
                 (apply-cont)))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{An Imperative Interpreter}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1->
\begin{alltt}
;; expression environment continuation -> expval
(define (value-of/k)
  (cases expression exp

    (true-exp ()
              (apply-cont k (bool-val #t)))
\end{alltt}

\item<1-> Becomes
\begin{alltt}
;; expression environment continuation -> expval
(define (value-of/k)
  (cases expression exp

    (true-exp ()
              (begin
                (set! val (bool-val #t))
                (apply-cont)))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{An Imperative Interpreter}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1->
\begin{alltt}
;; expression environment continuation -> expval
(define (value-of/k)
  (cases expression exp

    (false-exp ()
               (apply-cont k (bool-val #f)))
\end{alltt}

\item<1-> Becomes
\begin{alltt}
    (false-exp ()
               (begin
                 (set! val (bool-val #f))
                 (apply-cont)))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{An Imperative Interpreter}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1->
\begin{alltt}
;; expression environment continuation -> expval
(define (value-of/k)
  (cases expression exp

    (var-exp (var)
             (apply-cont k (apply-env env var)))
\end{alltt}

\item<1-> Becomes
\begin{alltt}
;; expression environment continuation -> expval
(define (value-of/k)
  (cases expression exp

    (var-exp (var)
             (begin
               (set! val (apply-env env var))
               (apply-cont)))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{An Imperative Interpreter}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1->
\begin{alltt}
;; expression environment continuation -> expval
(define (value-of/k)
  (cases expression exp

    (zero?-exp (exp1)
               (value-of/k exp1 env (zero?-cont k)))
\end{alltt}

\item<1-> Becomes
\begin{alltt}
;; expression environment continuation -> expval
(define (value-of/k)
  (cases expression exp

    (zero?-exp (exp1)
               (begin
                 (set! exp exp1)
                 (set! cont (zero?-cont cont))
                 (value-of/k)))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{An Imperative Interpreter}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1->
\begin{alltt}
;; expression environment continuation -> expval
(define (value-of/k)
  (cases expression exp

    (diff-exp (exp1 exp2)
              (value-of/k exp1 env (diff-cont1 exp2 env k)))
\end{alltt}

\item<1-> Becomes
\begin{alltt}
;; expression environment continuation -> expval
(define (value-of/k)
  (cases expression exp

    (diff-exp (exp1 exp2)
              (begin
                (set! exp exp1)
                (set! cont (diff-cont1 exp2 env cont))
                (value-of/k)))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{An Imperative Interpreter}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1->
\begin{alltt}
;; expression environment continuation -> expval
(define (value-of/k)
  (cases expression exp

    (if-exp (exp1 exp2 exp3)
            (value-of/k exp1 env (if-cont exp2 exp3 env k)))
\end{alltt}

\item<1-> Becomes
\begin{alltt}
;; expression environment continuation -> expval
(define (value-of/k)
  (cases expression exp

    (if-exp (exp1 exp2 exp3)
            (begin
              (set! exp exp1)
              (set! cont (if-cont exp2 exp3 env cont))
              (value-of/k)))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{An Imperative Interpreter}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1->
\begin{alltt}
;; expression environment continuation -> expval
(define (value-of/k)
  (cases expression exp

    (let-exp (vars exps body)
             (eval-rands/k exps env (let1-cont vars body env k)))
\end{alltt}

\item<1-> Becomes
\begin{alltt}
;; expression environment continuation -> expval
(define (value-of/k)
  (cases expression exp

    (let-exp (vars exps body)
             (begin
               (set! rands exps)
               (set! cont (let1-cont vars body env cont))
               (eval-rands/k)))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{An Imperative Interpreter}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1->
\begin{alltt}
;; expression environment continuation -> expval
(define (value-of/k)
  (cases expression exp

    (call-exp (rator rands)
              (value-of/k rator env (rator-cont rands env k)))
\end{alltt}

\item<1-> Becomes
\begin{alltt}
;; expression environment continuation -> expval
(define (value-of/k)
  (cases expression exp

    (call-exp (rator rands)
              (begin
                (set! exp rator)
                (set! cont (rator-cont rands env cont))
                (value-of/k)))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{An Imperative Interpreter}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1->
\begin{alltt}
;; expression environment continuation -> expval
(define (value-of/k)
  (cases expression exp

   (letrec-exp (names params bodies letrec-body)
    (mk-letrec-env/k 
      names params bodies env (letrec-cont letrec-body k))
\end{alltt}

\item<1-> Becomes
\begin{alltt}
;; expression environment continuation -> expval
(define (value-of/k)
  (cases expression exp

    (letrec-exp (names params bodies letrec-body)
                (begin
                  (set! letrec-names names)
                  (set! letrec-params params)
                  (set! letrec-bodies bodies)
                  (set! cont (letrec-cont letrec-body cont))
                  (mk-letrec-env/k)))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{An Imperative Interpreter}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1->
\begin{alltt}
(define (mk-letrec-env/k)
  (let* [\dotss]
    (begin
      (for-each (lambda (p)
                  (cases proc p
                    (procedure (p b ve)
                               (vector-set! ve 0 new-env))))
                (map (lambda (p) (expval2proc p))
                     temp-proc-vals))
      (apply-cont k new-env))))
\end{alltt}

\item<1-> Becomes
\begin{alltt}
(define (mk-letrec-env/k)
  (let* [\dotss]
    (begin
      (for-each (lambda (p)
                  (cases proc p
                    (procedure (p b ve)
                               (vector-set! ve 0 new-env))))
                (map (lambda (p) (expval2proc p))
                     temp-proc-vals))
      (begin
        (set! val new-env)
        (apply-cont)))))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{An Imperative Interpreter}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1->
\begin{alltt}
(define (create-let-lenv)
  (if (empty? vars)
      (apply-cont k env)
      (create-let-lenv (cdr vars)
                       (cdr vals)
                       (extend-env (car vars) (car vals) env)
                       k)
\end{alltt}

\item<1-> Becomes
\begin{alltt}
(define (create-let-lenv)
  (if (empty? vars)
      (begin
        (set! val env)
        (apply-cont))
      (begin
        ;; beware of dependencies between registers
        (set! env (extend-env (car vars) (car vals) env)) 
        (set! vars (cdr vars))
        (set! vals (cdr vals))
        (create-let-lenv))))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{An Imperative Interpreter}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1->
\begin{alltt}
(define (eval-rands/k)
  (if (null? rands)
      (apply-cont k \elist{})
      (value-of/k (car rands) 
                  env 
                  (eval-rands-cont1 (cdr rands) env k))
\end{alltt}

\item<1-> Becomes
\begin{alltt}
(define (eval-rands/k)
  (if (null? rands)
      (begin
        (set! val \elist{})
        (apply-cont))
      (begin
        (set! exp (car rands))
        (set! cont (eval-rands-cont1 (cdr rands) env cont))
        (value-of/k))))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{An Imperative Interpreter}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1->
\begin{alltt}
(define (apply-cont)
  (cases continuation cont
    (end-cont () val)

    (zero?-cont (saved-cont)
                (if (zero? (expval2num val))
                    (apply-cont saved-cont (bool-val #t))
                    (apply-cont cont (bool-val #f))))
\end{alltt}

\item<1-> Becomes
\begin{alltt}
(define (apply-cont)
  (cases continuation cont
    (end-cont () val) ;; no function call, no change

    (zero?-cont (saved-cont)
                (if (zero? (expval2num val))
                    (begin
                      (set! val (bool-val #t))
                      (set! cont saved-cont)
                      (apply-cont))
                    (begin
                      (set! val (bool-val #f))
                      (set! cont saved-cont)
                      (apply-cont))))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{An Imperative Interpreter}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1->
\begin{alltt}
(define (apply-cont)
  (cases continuation cont
    
    (let1-cont (the-vars body saved-env saved-cont)
     (create-let-lenv vars 
                      val 
                      saved-env 
                      (let2-cont body saved-cont)))
\end{alltt}

\item<1-> Becomes
\begin{alltt}
(define (apply-cont)
  (cases continuation cont
    
    (let1-cont (the-vars body saved-env saved-cont)
      (begin
        (set! vars the-vars)
        (set! vals val) ;; val is the list of evaluated RHSs
        (set! env saved-env)
        (set! cont (let2-cont body saved-cont))
        (create-let-lenv)))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{An Imperative Interpreter}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1->
\begin{alltt}
(define (apply-cont)
  (cases continuation cont
    
    (let2-cont (body saved-cont)
               (value-of/k body val saved-cont))
\end{alltt}

\item<1-> Becomes
\begin{alltt}
(define (apply-cont)
  (cases continuation cont
    
    (let2-cont (body saved-cont)
               (begin
                 (set! exp body)
                 (set! env val) ;; val is an env
                 (set! cont saved-cont)
                 (value-of/k)))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{An Imperative Interpreter}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1->
\begin{alltt}
(define (apply-cont)
  (cases continuation cont

    (if-cont (exp2 exp3 saved-env saved-cont)
             (if (expval2bool val)
                 (value-of/k exp2 saved-env saved-cont)
                 (value-of/k exp3 env saved-cont)))
\end{alltt}

\item<1-> Becomes
\begin{alltt}
(define (apply-cont)
  (cases continuation cont
    
    (if-cont (exp2 exp3 saved-env saved-cont)
             (if (expval2bool val)
                 (begin
                   (set! exp exp2)
                   (set! env saved-env)
                   (set! cont saved-cont)
                   (value-of/k))
                 (begin
                   (set! exp exp3)
                   (set! cont saved-cont)
                   (value-of/k))))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{An Imperative Interpreter}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1->
\begin{alltt}
(define (apply-cont)
  (cases continuation cont
    
    (letrec-cont (letrec-body saved-cont)
                 (value-of/k letrec-body val saved-cont))
\end{alltt}

\item<1-> Becomes
\begin{alltt}
(define (apply-cont)
  (cases continuation cont
    
    (letrec-cont (letrec-body saved-cont)
                 (begin
                   (set! exp letrec-body)
                   (set! env val) ;; val is an env
                   (set! cont saved-cont)
                   (value-of/k)))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{An Imperative Interpreter}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1->
\begin{alltt}
(define (apply-cont)
  (cases continuation cont

    (diff-cont1 (exp2 saved-env saved-cont)
      (value-of/k exp2 saved-env (diff-cont2 val saved-cont)))
\end{alltt}

\item<1-> Becomes
\begin{alltt}
(define (apply-cont)
  (cases continuation cont
    
    (diff-cont1 (exp2 saved-env saved-cont)
                (begin
                  (set! exp exp2)
                  (set! env saved-env)
                  (set! cont (diff-cont2 val saved-cont))
                  (value-of/k)))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{An Imperative Interpreter}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1->
\begin{alltt}
(define (apply-cont)
  (cases continuation cont
    
    (diff-cont2 (val1 saved-cont)
     (apply-cont saved-cont (num-val (- (expval2num val1)
                                        (expval2num val)))))
\end{alltt}

\item<1-> Becomes
\begin{alltt}
(define (apply-cont)
  (cases continuation cont
    
    (diff-cont2 (val1 saved-cont)
                (begin
                  (set! cont saved-cont)
                  (set! val (num-val (- (expval2num val1)
                                        (expval2num val))))
                  (apply-cont)))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{An Imperative Interpreter}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1->
\begin{alltt}
(define (apply-cont)
  (cases continuation cont
    
    (rator-cont (saved-rands saved-env saved-cont)
     (eval-rands/k 
       saved-rands saved-env (rands-cont val saved-cont)))
\end{alltt}

\item<1-> Becomes
\begin{alltt}
(define (apply-cont)
  (cases continuation cont
    
    (rator-cont (saved-rands saved-env saved-cont)
                (begin
                  (set! rands saved-rands)
                  (set! env saved-env)
                  (set! cont (rands-cont val saved-cont))
                  (eval-rands/k)))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{An Imperative Interpreter}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1->
\begin{alltt}
(define (apply-cont)
  (cases continuation cont
    
    (rands-cont (rator saved-cont)
     (apply-procedure/k (expval2proc rator) val saved-cont)
\end{alltt}

\item<1-> Becomes
\begin{alltt}
(define (apply-cont)
  (cases continuation cont
    
    (rands-cont (rator saved-cont)
      (begin
        (set! proc1 (expval2proc rator))
        (set! vals val) ;; val is the list of evaluated args
        (set! cont saved-cont)
        (apply-procedure/k)))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{An Imperative Interpreter}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1->
\begin{alltt}
(define (apply-cont)
  (cases continuation cont
    
    (eval-rands-cont1 (saved-rands saved-env saved-cont)
     (eval-rands/k 
      saved-rands saved-env (eval-rands-cont2 val saved-cont))
\end{alltt}

\item<1-> Becomes
\begin{alltt}
(define (apply-cont)
  (cases continuation cont
    
    (eval-rands-cont1 (saved-rands saved-env saved-cont)
      (begin
        (set! rands saved-rands)
        (set! env saved-env)
        (set! cont (eval-rands-cont2 val saved-cont))
        (eval-rands/k)))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{An Imperative Interpreter}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1->
\begin{alltt}
(define (apply-cont)
  (cases continuation cont
    
    (eval-rands-cont2 (first-rand saved-cont)
      (apply-cont saved-cont (cons first-rand val))
\end{alltt}

\item<1-> Becomes
\begin{alltt}
(define (apply-cont)
  (cases continuation cont
    
    (eval-rands-cont2 (first-rand saved-cont)
                      (begin
                        (set! cont saved-cont)
                        (set! val (cons first-rand val))
                        (apply-cont)))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}





\begin{frame}[fragile]
%\framesubtitle{An Imperative Interpreter}
\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> Add mult-exp and add-exp  to the imperative interpreter

\item<1-> 5.29

\end{itemize}
\end{scriptsize}
\end{frame}


\section{Exceptions}

\begin{frame}[fragile]
\framesubtitle{Exceptions}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> Remember exceptions (or throwing errors)?

\item<2-> Manage ordinary control flow

\item<2-> Alter the control context

\item<2-> Continuations may be used for these

\item<3-> Two new type of expressions in our language

\item<4-> expression $\rightarrow$ \texttt{try} expression \texttt{catch (}identifier\texttt{)} expression

\item<4-> Evaluate first expression and if it returns normally then its value is the value of the \texttt{try}-expression and the handler expression is ignored
    
\item<5-> expression $\rightarrow$ \texttt{raise} expression

\item<5-> Evaluate the expression and send that value to the most recent exception handler

\end{itemize}
\end{scriptsize}
\end{frame}


\begin{frame}[fragile]
\framesubtitle{Exceptions}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> Syntax
\begin{alltt}
(define the-grammar
  '((program (expression) a-program)
    	(expression (number) const-exp)
	\dotss{}
	(expression ("try" expression "catch" "(" identifier ")" expression) try-exp)
	(expression ("raise" expression) raise-exp)
))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{Exceptions}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> 
\begin{alltt}
(eval 
 "let f = proc (n)     ;; function to return n if not 0
           if zero?(n)
           then raise -1
           else n
  in try (f 0) catch (i) -(i, 1)") ;; handler subs 1 from its input
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{Exceptions}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> expression $\rightarrow$ \texttt{try} expression \texttt{catch (}identifier\texttt{)} expression

\item<1-> Need a continuation for what to do after evaluating the first expression
\begin{alltt}
(define-datatype continuation cont?
     \vdotss{}
  (try-cont
    (var symbol?)
    (handler-exp expression?) ;; use if abnormal evaluation end
    (env environment?)
    (cont continuation?))
\end{alltt}

\item<2-> expression $\rightarrow$ \texttt{raise} expression

\item<2-> Need a continuation for what to do after evaluating the expression

\item<2->
\begin{alltt}
(define-datatype continuation cont?
     \vdotss{}
  (try-cont
    (var symbol?)
    (handler-exp expression?) ;; use if abnormal evaluation end
    (env environment?)
    (cont cont?))

  (raise1-cont (saved-cont cont?)) 
  ;; save current cont to find handler (saved in a try-cont)
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{Exceptions}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1->
\begin{alltt}
(define (value-of/k exp env k)
  (cases expression exp
    \vdotss{}
    (try-exp (exp1 var handler)
      (value-of/k exp1 env (try-cont var handler env k)))
\end{alltt}

\item<2->
\begin{alltt}
    (raise-exp (exp1)
      (value-of/k exp1 env (raise1-cont k)))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{Exceptions}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> 
\begin{alltt}
(define (apply-cont k val)
  (cases continuation k
       \vdotss{}
    ;; no exception, proceed normally with saved continuation
    (try-cont (var handler-exp saved-env saved-cont)
      (apply-cont saved-cont val))
      
    ;; exception raised, find handler and apply
    (raise1-cont (saved-cont)
      (apply-handler val saved-cont))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{Exceptions}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> 
\begin{alltt}
;; apply-handler: expval cont \arrow{} Final Answer
(define (apply-handler val cont)
 (cases continuation cont
  (try-cont (var handler-exp saved-env saved-cont)
   (value-of/k 
    handler-exp ;; evaluate handler
    (extend-env var val saved-env) ;; binding for exception value
    saved-cont))
  (end-cont () (report-uncaught-exception)) ;; no handler
  (else (apply-handler val saved-cont)))) ;; keep searching
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
%\framesubtitle{Exceptions}
\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> 5.37, 5.38

\end{itemize}
\end{scriptsize}
\end{frame}


\section{Threads}

\begin{frame}[fragile]
\framesubtitle{Threads}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> One may want to have multiple computations at the same time in the same address space

\item<1-> Text editor: Spell checker, Back-up, Grammar check, etc.

\item<1-> Same address space and same process: threads

\item<2-> Interpreter will simulate the execution of multiple threads

\item<2-> Each thread is a computation in progress

\item<2-> Threads communicate through shared memory using assignment

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{Threads}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> Big picture (much from your OS course)

\item<1-> Pool of threads

\item<1-> Each thread: running, runnable, blocked

\item<2-> In our system, only one thread running at a time

\item<2-> Ready Queue: contains the runnable threads

\item<2-> Scheduler chooses which thread to run

\item<2-> Preemptive scheduling (quantum or time slice)

\item<2-> Start with \textbf{IMPLICIT-REFS Language}

\item<3-> spawn: creates a new thread
\begin{itemize}
\item takes one arg that should evaluate to a proc

\item When a thread is run an argument is passed to this proc

\item Does not run immediately‚Ä¶..put in the ready queue

\item spawn is executed for effect; don‚Äôt care return value
\end{itemize}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{Threads}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> Non-cooperating threads
\begin{alltt}
letrec
  noisy (l) = if null?(l)
              then 0
              else begin
                     print(car(l));
                     (noisy cdr(l))
                   end			
in begin
     spawn(proc (d) (noisy [1, 2, 3, 4, 5]);
     spawn(proc (d) (noisy [6, 7, 8, 9, 10]);
     print(100);
     33
   end
\end{alltt}

\item<2-> A trace
\begin{alltt}
100  main
1    first thread
2
3
6    second thread
7
8
4    first thread
5
9    second thread
10
returns 33  (when threads are done)
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{Threads}
%\framesubtitle{HOMEWORK}
\begin{tiny}
\begin{itemize}
\item<1-> Cooperating threads examples
\begin{alltt}
let buffer = 0 \textcolor{darkgreen}{one element buffer shared
}
in let producer = proc (n) \textcolor{darkgreen}{input: a buffer element n}
                    letrec wait(k) = 
                      if zero?(k)
                      then set buffer = n
                      else begin print(-(k,-200));
                                 (wait -(k,1)) end
                    in (wait 5) \textcolor{darkgreen}{execute wait loop 5 times}
        \textcolor{darkgreen}{ignores input, loops while buffer is 0 printing the timer}
   in let consumer = proc (d) 
                      letrec busywait (k) = 
                        if zero?(buffer)
                        then begin print(-(k,-100));
                                   (busywait -(k,-1)) end
                        else buffer
                      in (busywait 0)
      in begin spawn(proc (d) (producer 44));
               print(300);
               (consumer 86) end
\end{alltt}

\item<2->
\begin{alltt}
Trace
300
100    consumer runs for a while
101
205    producer runs for a while
204
203
102    consumer runs for a while
103
202    producer runs for a while
201
104    consumer runs for a while
105
producer sets buffer to 44 and stops
consumer returns 44
\end{alltt}

\end{itemize}
\end{tiny}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{Threads}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> Implementation

\item<1-> Continuation-passing IMPLICIT-REFS: Store + continuations

\item<1-> Add a scheduler


\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{Threads}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> Scheduler

\item<1-> Internal State
\begin{itemize}
\item Ready queue
\item Final answer ‚Äì value of main thread when done
\item Max time slice ‚Äì max steps a thread can run
\item Time remaining ‚Äì steps left for the running thread
\end{itemize}

\item<2-> Scheduler Interface
\begin{itemize}
\item init-scheduler: int \arrow{} void

\item place-on-ready-queue!: thread \arrow{} void

\item run-next-thread: () \arrow{} FinalAnswer, runs next thread or if none returns the final answer

\item set-final-answer!: expval \arrow{} void

\item time-expired?: () \arrow{} Bool

\item decrement-timer!: () \arrow{} void
\end{itemize}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{Threads}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> Queue Interface
\begin{alltt}
(define (empty-queue) \elist{})

(define null? null?)

(define (enqueue q val) (append q (list val)))

(define (dequeue q f) (f (car q) (cdr q)))
\end{alltt}

\item<1-> \texttt{f} updates the state of the scheduler and runs the first thread

\item<2-> State variables (registers)
\begin{alltt}
(define the-ready-queue    \quot{}uninitialized)

(define the-final-answer   \quot{}uninitialized)

(define the-max-time-slice \quot{}uninitialized)

(define the-time-remaining \quot{}uninitialized)
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{Threads}
%\framesubtitle{HOMEWORK}
\begin{tiny}
\begin{itemize}
\item<1-> Scheduler Implementation
\begin{alltt}
;; natnum>0 \arrow{} void
;; Purpose: Initialize the scheduler
(define (initialize-scheduler! ticks)
  (begin
    (set! the-ready-queue (empty-queue))
    (set! the-final-answer \quot{}uninitialized)
    (set! the-max-time-slice ticks)
    (set! the-time-remaining the-max-time-slice)))
\end{alltt}

\item<2->
\begin{alltt}    
;; thread \arrow{} (void)
;; Purpose: Place given thread in the ready queue
(define (place-on-ready-queue! th)
  (set! the-ready-queue (enqueue the-ready-queue th)))
\end{alltt}

\item<3->
\begin{alltt}
;; expval \arrow{} (void)
;; Purpose: Set the final answer register
(define (set-final-answer! val) (set! the-final-answer val))
\end{alltt}

\item<4->
\begin{alltt}
;;  \arrow{} Bool
;; Purpose: Determine if time slice has ended
(define (time-expired?) (zero? the-time-remaining))
\end{alltt}

\item<5->
\begin{alltt}
;;  \arrow{} (void)
;; Purpose: Decrement the time slice
(define (decrement-timer!)
  (set! the-time-remaining (- the-time-remaining 1)))
\end{alltt}

\item<6->
\begin{alltt}
;;  \arrow{} expval
;; Purpose: Run the next thread in the rady queue
(define (run-next-thread)
  (if (empty-queue? the-ready-queue)
      the-final-answer
      (dequeue the-ready-queue
               (lambda (first-ready-thread other-ready-threads)
                 (set! the-ready-queue other-ready-threads)
                 (set! the-time-remaining the-max-time-slice)
                 (first-ready-thread)))))
\end{alltt}

\end{itemize}
\end{tiny}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{Threads}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> Threads

\item<1-> thread = () \arrow{} expval

\item<1-> a procedure with no args that returns an expval

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{Threads}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> Interpreter

\item<1-> IMPLICIT-REFS refactored to be a continuation-passing interpreter (as we did for LETREC)

\item<1-> 
\begin{alltt}
(spawn-exp (exp) (value-of/k exp env (spawn-cont k)))
\end{alltt}

\item<2-> apply-cont
\begin{alltt}
(spawn-cont (saved-cont)
  (let ((proc1 (expval2proc val)))
   (begin
    (place-on-ready-queue!
      (lambda ()
       (apply-procedure/k 
        proc1
        (list (num-val 28)) ;; apply to dummy val
        (end-subthread-cont))))
    (apply-cont saved-cont (num-val 73))))) ;; return dummy val
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{Threads}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> Interpreter

\item<1-> What continuation should each thread be run in?

\item<2-> Main thread

\item<2-> record the value of the final answer

\item<2-> run any remaining threads

\item<3-> apply-cont
\begin{alltt}
	(end-main-thread-cont ()
      (begin 
        (set-final-answer! val)
        (run-next-thread)))
\end{alltt}

\item<4-> Other subthreads

\item<4-> ignore its value

\item<4-> runs remaining threads

\item<5-> apply-cont
\begin{alltt}
    (end-subthread-cont () 
      (run-next-thread))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{Threads}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> To evaluate a program:

\item<1-> initialize the store

\item<1-> initialize the scheduler

\item<1-> evaluate expression in the \texttt{end-main-thread-cont}

\item<2->
\begin{alltt}
;; value-of-program : natnum program \arrow{} expval
(define (value-of-program timeslice pgm)
  (initialize-store!)
  (initialize-scheduler! timeslice)
  (cases program pgm
    (a-program (exp1)
               (begin
                 (value-of/k
                  exp1
                  (empty-env)
                  (end-main-thread-cont))
                 the-final-answer))))
\end{alltt}

\item<3-> The wrapper function (eval)
\begin{alltt}
(define TIMESLICE 5)

;; string \arrow{} ExpVal
;; Purpose: Evaluate the given extended LC-program
(define (eval string)
  (value-of-program TIMESLICE (parse string)))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{Threads}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> Applying a continuation

\item<1-> If time has expired then place thread on ready queue interrupting the continuation application and run the next thread

\item<2-> If time has not expired then decrement the timer and apply the given continuation to the given value 
    
\item<3->
\begin{alltt}
(define (apply-cont k val)
  (if (time-expired?)
      (begin
        (place-on-ready-queue! (lambda () (apply-cont k val)))
        (run-next-thread))
      (begin
        (decrement-timer!)
        (cases continuation k
           \vdotss{}
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{Threads}
%\framesubtitle{HOMEWORK}
\begin{tiny}
\begin{itemize}
\item<1->
\begin{alltt}
     (eval "let x = 0
            in let mut = mutex()
               in let incr_x = proc (id) proc (dummy)
                                          begin set x = -(x, -1);
                                                print(x)
                                          end
                  in begin spawn((incr_x 100));
                           spawn((incr_x 200));
                           spawn((incr_x 300))
                     end")
\end{alltt}

\item<1-> What is the value of \texttt{x} when the program ends?

\item<2-> \texttt{set x = -(x, -1);}
\begin{alltt}
     LDR1 x
     LDR2 -1
     SUB 
     SET X R3
\end{alltt}

\item<3-> Trace
\begin{alltt}
     T1 runs and sets x to 1
     T2 runs and sets x to 2
     T3 runs and sets x to 3
\textcolor{red}{x is 3 after all threads run}
\end{alltt}

\item<3-> Trace
\begin{alltt}
     T1 LDR1 x  \textcolor{red}{Loads 0 as the value of x}
        LDR2 -1
        T1 is interrupted
\end{alltt}

\item<4->
\begin{alltt}
     T2 LDR1 x    \textcolor{red}{Loads 0 as the value of x}
        LDR2 -1
        SUB
        SET X R2  \textcolor{red}{mutates x to 1}
\end{alltt}

\item<5->
\begin{alltt}
     T2 LDR1 x    \textcolor{red}{Loads 1 as the value of x}
        LDR2 -1
        SUB
        SET X R3  \textcolor{red}{mutates x to 2}
\end{alltt}

\item<6->
\begin{alltt}
     T1 Restores 0 to R1 and -1 to R2
        SUB
        SET X R3  \textcolor{red}{mutates x to 1}
\textcolor{red}{x is 1 after all threads run}
\end{alltt}

\item<6-> Shared variables for communication are dangerous: assignment

\end{itemize}
\end{tiny}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{Threads}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> How do we avoid such interferences between processes?

\item<2-> Synchronization mechanism is needed

\item<3-> Binary semaphore or mutex: used to control access to shared variables and avoid busy waiting

\item<4-> Mutex
\begin{itemize}
  \item is open or closed
  \item has a queue of threads waiting for the mutex to become open
\end{itemize}


\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{Threads}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> Mutex interface

\item<1-> mutex
\begin{itemize}
\scriptsize
  \item no args
  \item creates an open mutex
\end{itemize}

\item<2-> wait
\begin{itemize}
\scriptsize
  \item one argument
  \item used to indicate access to a mutex
  \item open mutex \arrow{} mutex becomes closed and thread runs
  \item closed mutex \arrow{} thread put in the mutex‚Äôs queue
  \item returns void
\end{itemize}

\item<3-> signal
\begin{itemize}
\scriptsize
  \item single mutex argument
  \item used to release a mutex
  \item mutex closed and empty queue \arrow{} mutex open and thread continues
  \item mutex closed and non-empty queue \arrow{} one thread put in ready queue, queue remains closed, and thread continues executing
  \item returns no value
\end{itemize}

\item<4-> Mutex  guarantees
\begin{itemize}
\scriptsize
  \item only one thread has access to shared vars between wait and signal calls
  \item region where shared vars are accessed is called a \emph{critical region/section}
\end{itemize}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{Threads}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1->
\begin{alltt}
(eval 
 "let x = 0
  in let mut = mutex()
     in let incr_x = 
              proc (id) 
                proc (dummy)
                  begin
                    wait(mut);     
                    \textcolor{red}{set x = -(x, -1);  critical section
                    print(x);}      
                    signal(mut)
                  end
        in begin
             spawn((incr_x 100));
             spawn((incr_x 200));
             spawn((incr_x 300))
           end")
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{Threads}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> Implementation
\begin{alltt}
(define-datatype mutex mutex?
  (a-mutex
   (ref-to-closed? reference?)      ;; ref to bool closed or open
   (ref-to-wait-queue reference?))) ;; ref to (listof thread)
\end{alltt}

\item<2-> Mutexes are expressed values
\begin{alltt}
(define-datatype expval expval?
  (num-val
   (value number?))
  (bool-val
   (boolean boolean?))
  (proc-val
   (proc proc?))
  (mutex-val
   (mutex mutex?)))
   
(define expval2mutex
  (lambda (v)
    (cases expval v
      (mutex-val (m) m)
      (else (expval-extractor-error \quot{}mutex v)))))
\end{alltt}

\item<3-> In value-of/k
\begin{alltt}
(mutex-exp () (apply-cont k (mutex-val (new-mutex))))
\end{alltt}

\item<3->
\begin{alltt}
(define (new-mutex) (a-mutex (newref #f)   (newref \elist{})))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{Threads}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> wait

\item<1-> In \texttt{value-of/k}
\begin{alltt}
(wait-exp (exp) (value-of/k exp env (wait-cont k)))
\end{alltt}

\item<2-> In \texttt{apply-cont}
\begin{alltt}
(wait-cont (saved-cont)
  (wait-for-mutex
    (expval2mutex val)
    (lambda () (apply-cont saved-cont (num-val 52)))))
\end{alltt}

\item<3-> signal

\item<3-> In \texttt{value-of/k}
\begin{alltt}
(signal-exp (exp) (value-of/k exp env (signal-cont k)))
\end{alltt}

\item<4-> In \texttt{apply-cont}
\begin{alltt}
(signal-cont (saved-cont)
  (signal-mutex (expval2mutex val)
                (lambda () 
                  (apply-cont saved-cont (num-val 53)))))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{Threads}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> 
\begin{alltt}
;; mutex thread \arrow{} expval
;; Purpose: waits for mutex to be open.
(define (wait-for-mutex m th)
  (cases mutex m
    (a-mutex (ref-to-closed? ref-to-wait-queue)
      (cond [(deref ref-to-closed?)
             (setref! ref-to-wait-queue
                      (enqueue (deref ref-to-wait-queue) th))
             (run-next-thread)]
            [else (begin
                     (setref! ref-to-closed? #t)
                     (th))])))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
\framesubtitle{Threads}
%\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> 
\begin{alltt}
;; mutex thread \arrow{} expval
;; Purpose: To signal given mutex and run a waiting thread if any
(define (signal-mutex m th)
 (cases mutex m
  (a-mutex (ref-to-closed? ref-to-wait-queue)
   (let [(closed? (deref ref-to-closed?))
         (wait-queue (deref ref-to-wait-queue))]
    (if closed?
        (begin
         (if (empty? wait-queue)
             (setref! ref-to-closed? #f)
             (dequeue 
               wait-queue
               (lambda (first-waiting-th other-waiting-ths)
                (begin
                 (place-on-ready-queue! first-waiting-th)
                 (setref! ref-to-wait-queue other-waiting-ths)))))
         (th)) \textcolor{red}{;;error in book: Page 190, Fig 5.22}
        (th))))))
\end{alltt}

\end{itemize}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]
%\framesubtitle{Threads}
\framesubtitle{HOMEWORK}
\begin{scriptsize}
\begin{itemize}
\item<1-> 5.45, 5.47, 5.58 (outline the algorithm!)


\end{itemize}
\end{scriptsize}
\end{frame}


\end{document} 